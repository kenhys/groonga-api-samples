# インデックスカラムについて

インデックスにはバッファーとチャンクと呼ばれるものの2つがあります。
どちらもポスティングリストを保持しています。

レコードの削除によりインデックスを更新する必要がある場合、
トークンがどの文書に何回出現しているかというtfの値を0に書き換えます。

ただし、チャンクから削除するときは、チャンクは変更不可なので、バッファーにコピーを
作成してそのtfの値を0にします。バッファーとチャンクのどちらにもデータがある場合、
バッファーが優先されるようになっているので動作に支障はありません。

ただし、このように更新されていくとバッファーがいずれいっぱいになります。
するとバッファーを分割します。このとき、tf=0は無視してチャンクが作られます。

レコードの削除にともなってバッファーが追加されていくため、レコードを
削除したからといってデータベースが小さくなるわけではなく、しだいに肥大化します。

この仕組みのため、インデックスの更新の対象でバッファーが多ければあまり肥大化しませんが、
チャンクからバッファーへのコピーが多ければ、肥大化の程度は大きくなります。

## バッファーの分割について

バッファーとチャンクはセットで存在する。
バッファーがいっぱいになったら分割して新しいバッファーがつくられる。
このとき、tf=0なデータは新しいバッファーには含まれない。
（このとき、一時的につくられるバッファーに整理してから圧縮するということが行われる）
同様に削除されたデータを含むチャンクも除去する。ただしチャンクには多数のレコードが含まれるので、
このチャンクはどのレコードIDからはじまる、みたいなメタデータをみて処理するか決めている。
（チャンクを処理するにはデータを展開しないといけないので通常メタデータをみて処理するかスキップするかを決める）

メタデータがもっているレコードの開始位置は前のレコードからの差分で保持している。
（そのためこの差分がずれると管理しているメタデータと実際に含まれるレコードがずれておかしなことになる）

バッファーをマージしたり分割するときには中身が全部からになるチャンクというものある。
そのときはチャンクまるごと無視してマージする。

## テーブルの参照関係について


カラムが参照型のカラムかどうかはgrn_obj_is_reference_column(ctx, obj)で判定できる。
参照先のテーブルを取得するには、rangeを取得すればよい。

```
const grn_id range_id = grn_obj_get_range(ctx, obj);
grn_obj *range = grn_ctx_at(ctx, range_id);
```

カラムがデータカラムかどうかはgrn_obj_is_data_column(ctx, obj)で判定できる。
データカラムを参照しているインデックスカラムを取得するには、hookを探査して
オブジェクトのtypeがインデックスカラムであるかどうかをみるとよい。

```
for (hooks = DB_OBJ(obj)->hooks[GRN_HOOK_SET]; hooks; hooks = hooks->next) {
  grn_obj_default_set_value_hook_data *data = (void *)GRN_NEXT_ADDR(hooks);
  grn_obj *target = grn_ctx_at(ctx, data->target);
  if (target->header.type != GRN_COLUMN_INDEX) {
    continue;
  }
  /* target must be index column */
}
```

インデックスカラムからテーブル（語彙表）をたどるには、domainを参照するとよい。

```
grn_obj *lexicon = grn_ctx_at(ctx, target->header.domain);
```

